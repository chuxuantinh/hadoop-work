// # Script was Modified !!!!!, autogenerated version was as start.
// #
// Generated by CoffeeScript 1.10.0
//# #Angular-Inview
//# - Author: [Nicola Peduzzi](https://github.com/thenikso)
//# - Repository: https://github.com/thenikso/angular-inview
//    # - Install with: `bower install angular-inview`
//# - Version: **1.5.0**

(function () {
    'use strict';
    var _containersControllers, _windowEventsHandlerBinded, _windowInViewItems, addWindowInViewItem, angularInviewModule, bindWindowEvents, checkInView, debounce, getBoundingClientRect, getOffsetFromPercentage, getViewportHeight, offsetIsPercentage, removeWindowInViewItem, trackInViewContainer, triggerInViewCallback, getInViewCallbackOptions, setLastCheckedItemPropertyOnCallbackOptionsArray, unbindWindowEvents, untrackInViewContainer, windowCheckInView, windowEventsHandler,
        slice = [].slice;

    //# An [angular.js](https://angularjs.org) directive to evaluate an expression if
    //# a DOM element is or not in the current visible browser viewport.
    //# Use it in your Angular.js app by including the javascript and requireing it:
    //        #
    //# `angular.module('myApp', ['angular-inview'])`
    angularInviewModule = angular.module('angular-inview', [])

        //# ##in-view directive
        //#
        //# **Usage**
        //# ```html
        //# <any in-view="{expression}" [in-view-options="{object}"]></any>
        //# ```

        .directive('inView', [
            '$parse', function ($parse) {
                return {
                    //# Evaluate the expression passet to the attribute `in-view` when the DOM
                    //# element is visible in the viewport.
                    restrict: 'A',

                    //# If the `in-view` element is contained in a scrollable view other than the
                    //# window, that containing element should be [marked as a container](#in-view-container-directive).
                    require: '?^inViewContainer',
                    link: function (scope, element, attrs, containerController) {
                        var inViewFunc, item, options, performCheck, ref, ref0, ref1;
                        if (!attrs.inView) {
                            return;
                        }
                        inViewFunc = $parse(attrs.inView);
                        item = {
                            element: element,
                            wasInView: false,
                            offset: 0,
                            customDebouncedCheck: null,
                            oneTimeDebouncedCheck: null,

                            //# In the callback expression, the following variables will be provided:
                            //# - `$event`: the DOM event that triggered the inView callback.
                            //# The inView DOM element will be passed in `$event.inViewTarget`.
                            //# - `$inview`: boolean indicating if the element is in view
                            //# - `$inviewpart`: string either 'top', 'bottom' or 'both' or 'neither'
                            //# - `$$isLastCheckedItem`: boolean true or false
                            callback: function ($event, $inview, $inviewpart, $isLastCheckedItem) {
                                if ($event == null) {
                                    $event = {};
                                }
                                return scope.$evalAsync((function (_this) {
                                    return function () {
                                        $event.inViewTarget = element[0];
                                        return inViewFunc(scope, {
                                            '$event': $event,
                                            '$inview': $inview,
                                            '$inviewpart': $inviewpart,
                                            '$isLastCheckedItem': $isLastCheckedItem
                                        });
                                    };
                                })(this));
                            }
                        };


                        //# An additional `in-view-options` attribute can be specified to set offsets
                        //# that will displace the inView calculation and a debounce to slow down updates
                        //# via scrolling events.
                        if ((attrs.inViewOptions != null) && (options = scope.$eval(attrs.inViewOptions))) {
                            item.offset = options.offset || [options.offsetTop || 0, options.offsetBottom || 0];
                            if (options.debounce) {
                                item.customDebouncedCheck = debounce((function (event) {
                                    return checkInView([item], element[0], event);
                                }), options.debounce);
                            }
                        }

                        if (item.customDebouncedCheck == null) {
                            item.oneTimeDebouncedCheck = debounce((function (event) {
                                return checkInView([item], element[0], event);
                            }), 50);
                        }

                        // #### Mad  IF IF IF condition
                        //# A series of checks are set up to verify the status of the element visibility.
                        performCheck = (
                            ref = (ref1 = ( (ref0 = item.oneTimeDebouncedCheck ) != null
                                                                                                            ? ref0
                                                                                                            : item.customDebouncedCheck
                            )) != null
                                ? ref1
                                :
                                    containerController != null
                                        ? containerController.checkInView
                                        : void 0
                        ) != null
                            ? ref
                            : windowCheckInView;

                        if (containerController != null) {
                            containerController.addItem(item);
                        } else {
                            addWindowInViewItem(item);
                        }

                        //# This checks will be performed immediatly and when a relevant measure changes.
                        setTimeout(function () {
                            performCheck.apply(this)
                        });


                        //# When the element is removed, all the logic behind in-view is removed.
                        //# One might want to use `in-view` in conjunction with `ng-if` when using
                        //# the directive for lazy loading.

                        return scope.$on('$destroy', function () {
                            if (containerController != null) {
                                containerController.removeItem(item);
                            }
                            return removeWindowInViewItem(item);
                        });
                    }
                };
            }
        ]).directive('inViewContainer', function () {
            return {
                //# Use this as an attribute or a class to mark a scrollable container holding
                //# `in-view` directives as children.

                restrict: 'AC',
                //# This directive will track child `in-view` elements.

                controller: [
                    '$element', function ($element) {
                        this.items = [];
                        this.addItem = function (item) {
                            return this.items.push(item);
                        };
                        this.removeItem = function (item) {
                            var i;
                            return this.items = (function () {
                                var j, len, ref, results;
                                ref = this.items;
                                results = [];
                                for (j = 0, len = ref.length; j < len; j++) {
                                    i = ref[j];
                                    if (i !== item) {
                                        results.push(i);
                                    }
                                }
                                return results;
                            }).call(this);
                        };
                        this.checkInView = (function (_this) {
                            return function (event) {
                                var i, j, len, ref;
                                ref = _this.items;
                                for (j = 0, len = ref.length; j < len; j++) {
                                    i = ref[j];
                                    if (i.customDebouncedCheck != null) {
                                        i.customDebouncedCheck();
                                    }
                                }

                                return checkInView((function () {
                                    var k, len1, ref1, results;
                                    ref1 = this.items;
                                    results = [];
                                    for (k = 0, len1 = ref1.length; k < len1; k++) {
                                        i = ref1[k];
                                        if (i.customDebouncedCheck == null) {
                                            results.push(i);
                                        }
                                    }
                                    return results;
                                }).call(_this), $element[0], event);

                            };

                        })(this);

                        return this;
                    }
                ],
                //# Custom checks on child `in-view` elements will be triggered when the
                //# `in-view-container` scrolls.

                link: function (scope, element, attrs, controller) {
                    element.bind('scroll', controller.checkInView);
                    trackInViewContainer(controller);
                    return scope.$on('$destroy', function () {
                        element.unbind('scroll', controller.checkInView);
                        return untrackInViewContainer(controller);
                    });
                }
            };
        });


//    # ## Utilities
//
//# ### items management
//
//# The collectin of all in-view items. Items are object with the structure:
//        # ```
//# {
//# 	element: <angular.element>,
//# 	offset: <number>,
//# 	wasInView: <bool>,
//# 	callback: <funciton>
//# }
//# ```

    _windowInViewItems = [];

    addWindowInViewItem = function (item) {
        _windowInViewItems.push(item);
        return bindWindowEvents();
    };

    removeWindowInViewItem = function (item) {
        var i;
        _windowInViewItems = (function () {
            var j, len, results;
            results = [];
            for (j = 0, len = _windowInViewItems.length; j < len; j++) {
                i = _windowInViewItems[j];
                if (i !== item) {
                    results.push(i);
                }
            }
            return results;
        })();
        return unbindWindowEvents();
    };


//# List of containers controllers
    _containersControllers = [];

    trackInViewContainer = function (controller) {
        _containersControllers.push(controller);
        return bindWindowEvents();
    };

    untrackInViewContainer = function (container) {
        var c;
        _containersControllers = (function () {
            var j, len, results;
            results = [];
            for (j = 0, len = _containersControllers.length; j < len; j++) {
                c = _containersControllers[j];
                if (c !== container) {
                    results.push(c);
                }
            }
            return results;
        })();
        return unbindWindowEvents();
    };




//# ### Events handler management
    _windowEventsHandlerBinded = false;

    windowEventsHandler = function (event) {
        var c, j, len;
        for (j = 0, len = _containersControllers.length; j < len; j++) {
            c = _containersControllers[j];
            c.checkInView(event);

        }
        if (_windowInViewItems.length) {
            return windowCheckInView(event);
        }
    };

    bindWindowEvents = function () {
        //# The bind to window events will be added only if actually needed.
        if (_windowEventsHandlerBinded) {
            return;
        }
        _windowEventsHandlerBinded = true;
        return angular.element(window).bind('checkInView click ready scroll resize', windowEventsHandler);
    };

    unbindWindowEvents = function () {
        //# All the window bindings will be removed if no directive requires to be checked.
        if (!_windowEventsHandlerBinded) {
            return;
        }
        if (_windowInViewItems.length || _containersControllers.length) {
            return;
        }
        _windowEventsHandlerBinded = false;
        return angular.element(window).unbind('checkInView click ready scroll resize', windowEventsHandler);
    };


//# ### InView checks
//# This method will call the user defined callback with the proper parameters if neccessary.

    triggerInViewCallback = function (callbackOptions) {
        if (callbackOptions.isCalled) {
            return callbackOptions.callbackFactory();
        }
    };

    getInViewCallbackOptions = function (event, item, inview, isTopVisible, isBottomVisible) {
        var elOffsetTop,
            inviewpart,
            callbackOptions =  {
                isCalled: false,
                isLastCheckedItem: false,
                callbackFactory: function () {}
            };

        if (inview) {
            elOffsetTop = getBoundingClientRect(item.element[0]).top + window.pageYOffset;
            inviewpart = (isTopVisible && isBottomVisible && 'neither') || (isTopVisible && 'top') || (isBottomVisible && 'bottom') || 'both';

            //# The callback will be called only if a relevant value has changed.
            //# However, if the element changed it's position (for example if it has been
            //# pushed down by dynamically loaded content), the callback will be called anyway.
            if (!(item.wasInView && item.wasInView === inviewpart && elOffsetTop === item.lastOffsetTop)) {
                item.lastOffsetTop = elOffsetTop;
                item.wasInView = inviewpart;
                callbackOptions.isCalled = true;
                callbackOptions.callbackFactory = function () {
                    return item.callback(event, true, inviewpart, callbackOptions.isLastCheckedItem);
                }
            }
        } else if (item.wasInView) {
            item.wasInView = false;
            callbackOptions.isCalled = true;
            callbackOptions.callbackFactory = function () {
                return item.callback(event, false, 'neither', callbackOptions.isLastCheckedItem);
            }

        }
        return callbackOptions;
    };

    setLastCheckedItemPropertyOnCallbackOptionsArray = function (callbackOptionsArray) {
        var k, isContinue = true, len = callbackOptionsArray.length, optionsItem;
        for (k = len - 1; k >= 0 && isContinue; k--) {
            optionsItem = callbackOptionsArray[k];
            if (optionsItem.isCalled) {
                optionsItem.isLastCheckedItem = true;
                isContinue = false;
            }
        }
    };

    //# The main function to check if the given items are in view relative to the provided container.
    checkInView = function (items, container, event) {
        var bounds, boundsBottom, boundsTop, element, item, j, k, m, len, len1, len2, ref, ref1, ref2, ref3, results, viewport,
            callbackOptionsAll = [];

        //# It first calculate the viewport.
        viewport = {
            top: 0,
            bottom: getViewportHeight()
        };
        //	# Restrict viewport if a container is specified.
        if (container && container !== window) {
            bounds = getBoundingClientRect(container);

            //# Shortcut to all item not in view if container isn't itself.
            if (bounds.top > viewport.bottom || bounds.bottom < viewport.top) {

                for (j = 0, len = items.length; j < len; j++) {
                    item = items[j];
                    callbackOptionsAll.push(getInViewCallbackOptions(event, item, false, false, false));
                }
                setLastCheckedItemPropertyOnCallbackOptionsArray(callbackOptionsAll);
                for (m = 0, len2 = callbackOptionsAll.length; m < len2; m++) {
                    triggerInViewCallback(callbackOptionsAll[m]);
                }
                return;
            }

            //# Actual viewport restriction.
            if (bounds.top > viewport.top) {
                viewport.top = bounds.top;
            }
            if (bounds.bottom < viewport.bottom) {
                viewport.bottom = bounds.bottom;
            }
        }

        //# Calculate inview status for each item.
        results = [];
        callbackOptionsAll = [];
        for (k = 0, len1 = items.length; k < len1; k++) {
            //# Get the bounding top and bottom of the element in the viewport.

            item = items[k];
            element = item.element[0];
            bounds = getBoundingClientRect(element);

            //	# Apply offset.
            boundsTop = bounds.top + (offsetIsPercentage(item.offset) ? getOffsetFromPercentage(bounds, item.offset) : parseInt((ref = (ref1 = item.offset) != null ? ref1[0] : void 0) != null ? ref : item.offset));
            boundsBottom = bounds.bottom + (offsetIsPercentage(item.offset) ? getOffsetFromPercentage(bounds, item.offset) : parseInt((ref2 = (ref3 = item.offset) != null ? ref3[1] : void 0) != null ? ref2 : item.offset));
            //# Calculate parts in view.
            if (boundsTop < viewport.bottom && boundsBottom >= viewport.top) {
                callbackOptionsAll.push(getInViewCallbackOptions(event, item, true, boundsBottom > viewport.bottom, boundsTop < viewport.top));
            } else {
                callbackOptionsAll.push(getInViewCallbackOptions(event, item, false, false, false));
            }
        }
        setLastCheckedItemPropertyOnCallbackOptionsArray(callbackOptionsAll);
        for (m = 0, len2 = callbackOptionsAll.length; m < len2; m++) {
            results.push(triggerInViewCallback(callbackOptionsAll[m]));
        }
        return results;
    };


    // # ### Utility functions

    //# Checks if the provided offset value is a percentage or not
    offsetIsPercentage = function (offset) {
        return typeof offset === 'string' && offset.slice(-1) === '%';
    };

    //# Calculates the offset in pixels based on the percentage provided
    getOffsetFromPercentage = function (bounds, offsetPercentage) {
        var percentage;
        percentage = offsetPercentage.substring(0, offsetPercentage.length - 1);
        return (bounds.bottom - bounds.top) * (percentage / 100);
    };

    //# Returns the height of the window viewport
    getViewportHeight = function () {
        var height, mode, ref;
        height = window.innerHeight;
        if (height) {
            return height;
        }
        mode = document.compatMode;
        if (mode || !(typeof $ !== "undefined" && $ !== null ? (ref = $.support) != null ? ref.boxModel : void 0 : void 0)) {
            height = mode === 'CSS1Compat' ? document.documentElement.clientHeight : document.body.clientHeight;
        }
        return height;
    };

    //# Polyfill for `getBoundingClientRect`
    getBoundingClientRect = function (element) {
        var el, parent, top;
        if (element.getBoundingClientRect != null) {
            return element.getBoundingClientRect();
        }
        top = 0;
        el = element;
        while (el) {
            top += el.offsetTop;
            el = el.offsetParent;
        }
        parent = element.parentElement;
        while (parent) {
            if (parent.scrollTop != null) {
                top -= parent.scrollTop;
            }
            parent = parent.parentElement;
        }
        return {
            top: top,
            bottom: top + element.offsetHeight
        };
    };

    //# Debounce a function.
    debounce = function (f, t) {
        var timer;
        timer = null;
        return function () {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            if (timer != null) {
                clearTimeout(timer);
            }
            return timer = setTimeout((function () {
                return f.apply(null, args);
            }), t != null ? t : 100);
        };
    };

    //# The main funciton to perform in-view checks on all items.
    windowCheckInView = function (event) {
        var i, j, len;
        for (j = 0, len = _windowInViewItems.length; j < len; j++) {
            i = _windowInViewItems[j];
            if (i.customDebouncedCheck != null) {
                i.customDebouncedCheck();
            }
        }
        return checkInView((function () {
            var k, len1, results;
            results = [];
            for (k = 0, len1 = _windowInViewItems.length; k < len1; k++) {
                i = _windowInViewItems[k];
                if (i.customDebouncedCheck == null) {
                    results.push(i);
                }
            }
            return results;
        })(), null, event);
    };

    if (typeof define === 'function' && define.amd) {
        define(['angular'], angularInviewModule);
    } else if (typeof module !== 'undefined' && module && module.exports) {
        module.exports = angularInviewModule;
    }

}).call(this);
